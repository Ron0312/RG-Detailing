<script>
  import { trackEvent } from '../lib/analytics';

  // Make trackEvent available globally for inline onclick handlers (e.g. Footer)
  window.trackEvent = trackEvent;

  // Simple Bot Check (Global scope)
  // Prevents bots from attaching listeners and exhausting rate limits
  const isBot = /bot|googlebot|crawler|spider|robot|crawling|bingbot|yandex|baidu|slurp|facebookexternalhit|headless|lighthouse|adsbot/i.test(navigator.userAgent);

  if (!isBot) {
      // Track Page Load
      window.addEventListener('load', () => {
        trackEvent('page_view', {
          device: window.innerWidth < 768 ? 'Mobile' : 'Desktop',
          platform: navigator.platform
        });

        // Performance Tracking (LCP, CLS)
        if ('PerformanceObserver' in window) {
            try {
                // LCP
                new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    if (entries.length > 0) {
                        const lastEntry = entries[entries.length - 1];
                        trackEvent('performance_metric', { metric: 'LCP', value: Math.round(lastEntry.startTime) });
                    }
                }).observe({ type: 'largest-contentful-paint', buffered: true });

                // CLS (Cumulative Layout Shift)
                let clsValue = 0;
                new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        if (!entry.hadRecentInput) {
                            clsValue += (entry as any).value;
                        }
                    }
                }).observe({ type: 'layout-shift', buffered: true });

                // Report CLS on visibility change (exit)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden' && clsValue > 0) {
                        trackEvent('performance_metric', { metric: 'CLS', value: clsValue.toFixed(4) });
                        // Don't reset clsValue as we want cumulative for the session if they come back?
                        // Actually, standard is session-window based, but for simple analytics, lifetime of page view is fine.
                    }
                });

            } catch (e) {
                // Ignore observer errors
            }
        }

        // SEO Health Check (Client-Side)
        if (!document.title || document.title.length < 5) {
            trackEvent('seo_issue', { type: 'missing_title', url: window.location.pathname });
        }
        const metaDesc = document.querySelector('meta[name="description"]');
        if (!metaDesc || !metaDesc.getAttribute('content') || metaDesc.getAttribute('content').length < 10) {
            trackEvent('seo_issue', { type: 'missing_description', url: window.location.pathname });
        }
      });

      // Track Time on Page (Heartbeat + Visibility + Idle Check)
      let startTime = Date.now();
      let timeTracked = 0;
      let lastActivity = Date.now();

      // Update activity timestamp on interaction
      ['mousedown', 'keydown', 'scroll', 'touchstart'].forEach(evt =>
        document.addEventListener(evt, () => { lastActivity = Date.now(); }, { passive: true })
      );

      const trackDuration = () => {
        // Stop tracking if idle for > 5 minutes to prevent log flooding
        if (Date.now() - lastActivity > 5 * 60 * 1000) return;

        const now = Date.now();
        const duration = Math.round((now - startTime) / 1000); // seconds
        if (duration > timeTracked && duration > 5) {
            trackEvent('time_on_page', { duration: duration - timeTracked, total: duration });
            timeTracked = duration;
        }
      };

      // Heartbeat every 30 seconds
      setInterval(trackDuration, 30000);

      // Visibility Change
      document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
              trackDuration();
          }
      });

      // Outbound Link Tracking
      document.addEventListener('click', (e) => {
          const link = (e.target as HTMLElement).closest('a');
          if (link && link.href) {
              const url = new URL(link.href);
              if (url.origin !== window.location.origin) {
                  trackEvent('outbound_click', { url: link.href });
              }
          }
      });

      // Intent Tracking: Copy
      document.addEventListener('copy', () => {
          const selection = document.getSelection();
          const text = selection ? selection.toString() : '';
          if (text.length > 5 && text.length < 100) { // Ignore huge copies or tiny accidental ones
              trackEvent('intent_copy', { text: text.substring(0, 50) });
          }
      });

      // Track Scroll Depth, Reading Behavior & Re-Engagement
      const thresholds = [25, 50, 75, 100];
      const tracked = new Set();
      let scrollStartTime = Date.now();
      let lastScrollY = 0;
      let maxScrollY = 0;
      let reEngagementTracked = false;

      const handleScroll = () => {
          const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
          const scrolled = window.scrollY;
          const percentage = Math.round((scrolled / scrollHeight) * 100);

          // Track Depth
          thresholds.forEach(t => {
              if (percentage >= t && !tracked.has(t)) {
                  tracked.add(t);

                  // Calculate reading speed to reach 50%
                  if (t === 50) {
                      const timeToHalf = (Date.now() - scrollStartTime) / 1000;
                      const behavior = timeToHalf < 3 ? 'skim' : 'read'; // <3s to scroll 50% = skimming
                      trackEvent('reading_behavior', { type: behavior, seconds: Math.round(timeToHalf) });
                  }

                  trackEvent('scroll_depth', { depth: t });
              }
          });

          // Track Re-Engagement (Scrolling up > 300px after reaching > 500px)
          if (scrolled > maxScrollY) maxScrollY = scrolled;

          if (!reEngagementTracked && maxScrollY > 500 && lastScrollY - scrolled > 300) {
              reEngagementTracked = true;
              trackEvent('re_engagement', { depth: percentage });
          }

          lastScrollY = scrolled;
      };

      // Throttle scroll event
      let ticking = false;
      window.addEventListener('scroll', () => {
          if (!ticking) {
              window.requestAnimationFrame(() => {
                  handleScroll();
                  ticking = false;
              });
              ticking = true;
          }
      }, { passive: true });
  }
</script>
